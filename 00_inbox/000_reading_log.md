---


---
### 1. 什麼是 API 設計模式，以及為何它們對建構 Web API 至關重要？

API 設計模式是針對應用程式介面 (API) 的可重複使用的藍圖或解決方案，用於解決常見的設計問題。它們如同軟體開發的建築藍圖，提供了一種標準化的方法來建構和組織 API，而非每次都從零開始。

API 設計模式之所以重要，主要有以下幾個原因：

- **剛性與難以改變**：與內部軟體專案不同，Web API 是公開的、供遠端使用者使用的，這使得對 API 設計進行增量改進變得非常困難。一旦 API 發佈並被使用，任何重大變更都可能破壞現有客戶端的運作。因此，在一開始就採用經過驗證的模式來「第一次就把事情做對」至關重要。
- **一致性與可預測性**：透過遵循標準模式，API 變得更加一致和可預測。使用者無需深入閱讀所有文件就能理解 API 的運作方式，因為他們可以依賴已學到的模式來推斷未來的行為。這大大降低了學習成本，並提升了開發人員的生產力。
- **抽象化複雜性**：設計模式允許 API 抽象化底層的實作細節，例如運算能力或儲存機制。這使得開發人員可以專注於解決獨特的業務問題，而不是重複解決常見的 API 設計挑戰。

總之，API 設計模式提供了一套經過實戰考驗的指南，旨在減少 API 設計中的附帶複雜性，使開發者能夠建構出既可靠、易於學習，又能優雅演進的 API。

### 2. 「資源導向」的 API 是什麼，它如何提升 API 的可用性？

資源導向的 API 是一種設計模式，它將 API 的重點從執行的「動作」（遠端程序呼叫或 RPC）轉移到管理和互動的「事物」（資源）。這種方法透過標準化兩個主要方面來提升 API 的可用性：

- **標準化資源**：API 所儲存和互動的關鍵概念被定義為「資源」。這些資源代表了系統中的實體，例如 FlightReservation、ChatRoom 或 Message。
- **標準化方法**：對於這些資源，API 僅限於使用一小組標準方法（例如，Create、Get、List、Delete 和 Update）。這些標準方法以 `StandardMethod<Resource>()` 的形式套用到每個資源，形成了可預測的動作。

這種標準化大大簡化了 API 的學習曲線。一旦使用者熟悉了這五個標準方法，他們就可以將這些知識應用到任何新的資源上。例如，了解如何 CreateChatRoom () 也意味著了解如何 GetChatRoom ()、ListChatRooms () 等等。這種模式的力量使得開發人員能夠快速上手並與 API 互動，而無需記憶大量不同的 RPC 名稱和其各自獨特的行為。

相較於 RPC 導向的 API，資源導向的 API 通常更容易學習、理解和記憶，因為它們利用了可組合組件和一致模式的力量。

### 3. 如何判斷一個 API 是否「良好」？

一個「良好」的 API 通常具備以下四個主要特徵：

1. **可操作性 (Operational)**：這是最基本也是最重要的特性。一個良好的 API 必須確實執行使用者期望的功能。如果一個 API 用於文本翻譯，它就必須能夠正確地翻譯文本。此外，它還必須滿足非功能性需求，例如低延遲和高準確性。
2. **表達性 (Expressive)**：API 的介面必須允許使用者清晰、簡潔地表達他們想做的事情。功能不應被隱藏或需要透過不尋常的變通方法來存取。例如，與其讓使用者透過翻譯文本來「猜測」語言，不如提供一個明確的 DetectLanguage () 方法。表達性也強調「讓常用情況變得出色，讓進階情況成為可能」，這意味著常見的操作應該簡單易用，而複雜的功能則應以適當的方式暴露。
3. **簡潔性 (Simple)**：API 應該盡可能簡潔，但不過度簡化。它應該只暴露使用者真正需要的功能，並避免不必要的複雜性。這也意味著要避免過度減少 RPC 數量而導致功能混淆，或過度引入抽象而使基本操作變得複雜。
4. **可預測性 (Predictable)**：一個好的 API 應該讓使用者能夠根據他們已學到的知識來預測未來的行為。例如，如果一個欄位在某個請求訊息中被稱為 text，使用者就會期望在其他相關訊息中也採用相同的命名。不一致的命名或行為會導致使用者生產力停滯，因為他們需要花時間去理解為何他們的預期落空。

總之，一個良好的 API 不僅要能執行任務，還要讓使用者以直觀、簡單的方式完成任務，並始終保持一致和可預測的行為。

### 4. 在 API 設計中，如何有效地命名各種組件？

在 API 設計中，命名是一項至關重要的任務，因為名稱的壽命往往比預期的要長，且更改公開名稱的成本很高（如同更改地址或電話號碼）。一個「良好」的名稱應具備以下特點：

- **表達性 (Expressive)**：名稱應該清晰地傳達其含義和用途，避免歧義。例如，model_topic 或 messaging_topic 比單獨的 topic 更能避免混淆，特別是在多重語境中。
- **簡潔性 (Simple)**：名稱應盡可能簡潔，但仍能傳達必要資訊。
- **可預測性 (Predictable)**：透過在整個 API 中一致地使用相同名稱來代表相同的事物，並使用不同名稱代表不同的事物，讓使用者能夠依賴已學到的知識來預測未來的命名。

以下是一些關於命名組件的通用指南：

- **語言**：除非有特定原因，否則應普遍使用「美式英語」的概念和拼寫，以實現最大的互通性。
- **文法**：
- **動詞**：在 RPC 和自訂方法名稱中，應使用動詞的「祈使語氣」（例如 CreateChatRoom），而非「指示語氣」（例如 CreateChatRoom ()）。
- **介系詞**：名稱中的介系詞（如「with」、「to」、「for」）通常是「API 異味 (API smell)」，暗示底層設計可能存在問題，應重新考慮（例如，BookWithAuthor 可能暗示需要使用欄位遮罩或視圖）。
- **複數化**：資源名稱通常使用「單數形式」（例如 Book、Person），而資源集合名稱通常使用「複數形式」（例如 /books、/people）。對於不規則複數形式，應查詢正確的用法（例如 people 而非 persons，octopuses 而非 octopi）。
- **語法**：
- **大小寫**：對不同 API 組件使用一致的大小寫約定（例如，資源使用「大駝峰式命名法」UserSettings，欄位使用「蛇形命名法」first_name 或「小駝峰式命名法」firstName）。
- **保留字**：避免使用程式語言中的保留字作為 API 中的名稱。
- **語境 (Context)**：命名時要考慮 API 的語境，因為相同的詞語在不同語境下可能意味著完全不同的事物。
- **資料類型和單位 (Data Types and Units)**：
- 對於原始資料類型（如數字、字串），如果其含義或單位不夠明顯，應將單位包含在名稱中（例如 sizeBytes、dimensionsPixels）。
- 如果單一原始類型不足以表達複雜概念，應使用更豐富的資料類型（介面）來提升清晰度（例如，使用 Dimensions 介面包含 lengthPixels 和 widthPixels，而非單一字串 dimensionsPixels: string）。
- 如果數值僅是符號或代碼而非用於算術運算，則應使用字串類型來表示（例如，數字型 ID 應為字串）。

透過遵循這些指南，API 名稱將會更具表達性、簡潔性、可預測性，並減少使用者混淆。

### 5. API 中的資料類型（布林、數字、字串、列舉、列表、映射）應如何處理，特別是在序列化和預設值方面？

在 API 設計中，正確處理資料類型及其序列化和預設值對於確保互通性、清晰度和穩定性至關重要：

- **缺失 vs. Null**：在許多序列化格式中，null 值表示「無值」，而「缺失」則表示欄位完全不存在。API 必須明確定義如何區分和處理這兩種情況，以及它們對算術或邏輯運算的影響。
- **布林 (Booleans)**：
- **命名**：通常建議使用「正向」的布林欄位命名（例如 allowChatbots 而非 disallowChatbots），因為雙重否定會增加認知負擔。
- **預設值**：可以選擇欄位的名稱，使零值（false）提供所需的預設行為。
- **未來彈性**：如果一個布林值可能在未來演變為需要更細緻答案的問題，應考慮使用更靈活的資料類型或結構。
- **數字 (Numbers)**：
- **界限 (Bounds)**：應考慮數字的上限、下限和零值。內部應依賴 64 位元整數類型以預留成長空間。由於不同程式語言處理大數字和浮點數的方式不同，API 應明確定義其支援的數字範圍和精度。
- **預設值**：避免將零值（0 或 0.0）作為預設值的標誌，因為零本身可能是一個有意義的值。
- **序列化**：對於大整數和浮點數，為了避免精度問題和跨語言的不一致性，最佳實踐是將它們序列化為「字串」值（例如 "0.1" 而非 0.1），並依賴專門的任意精度庫進行解析和運算。
- **字串 (Strings)**：
- **界限**：應設定字串欄位的最大長度，並在輸入超出限制時「拒絕」而非截斷，以避免誤導和不可預測的行為。
- **預設值**：空字串（""）可以用作預設值的標誌，如果空字串本身不是有效值。否則，可以考慮使用特定值（例如" default"）來指示預設行為。
- **序列化**：除非有特殊原因，API 應統一使用「UTF-8」編碼。對於表示識別符的字串，應要求使用「Unicode 標準化形式 C (Normalization Form C)」以避免由於位元組表示不同而導致的語義相同但二進制不同的值。
- **列舉 (Enumerations)**：
- **應避免使用**：在 Web API 中，列舉常常會引入靈活性和清晰度的問題，特別是當新值被加入時，客戶端需要更新才能理解。
- **替代方案**：通常應使用「字串」欄位並在伺服器端進行驗證。這允許新值在客戶端無需更新的情況下被處理（即使它們尚未被客戶端代碼明確支持）。
- **列表 (Lists / Arrays)**：
- **原子性 (Atomicity)**：列表欄位應被視為「原子性的資料單元」，即對其的修改應是整體替換，而非單獨更新其中一個元素。這有助於避免並發問題和資料不一致。
- **同質性 (Homogeneity)**：列表值應保持「同質性」，即同一列表中不應混合不同資料類型，以避免混淆。
- **界限**：應對列表中的最大項目數和每個項目的最大大小設定界限，並在輸入超出限制時「拒絕」而非截斷。
- **預設值**：空列表（[]）通常是有效的零值。如果需要表示預設行為，則列表可能不是正確的資料類型，應考慮使用獨立的子集合資源。
- **映射 (Maps)**：
- **自訂資料類型與動態鍵值對**：映射可以是具有預定義模式的自訂資料類型（介面），也可以是任意的動態鍵值對集合。
- **界限**：應為映射中的鍵數、每個鍵的大小和每個值的大小設定上限。
- **預設值**：通常可以區分空映射（{}）和 null 值，並將 null 用於指示 API 應選擇預設行為。
- **鍵的序列化**：由於映射鍵在技術上是唯一識別符，因此它們也應使用 UTF-8 編碼和 Unicode 標準化形式 C。

正確地選擇和處理這些資料類型，將有助於建構出穩健、易於理解和使用的 API。

### 6. 什麼是好的 API 識別符，以及它們應如何產生和管理？

API 識別符是用於唯一指向 API 中特定資源的值。一個「良好」的識別符應具備以下重要屬性：

- **易於使用 (Easy to use)**：應簡單明瞭，且不應包含特殊字元。
- **唯一性 (Unique)**：在整個 API 的生命週期內，每個資源都應具有唯一的識別符，即使資源被刪除也不應重複使用。
- **持久性 (Permanent)**：一旦分配給資源，識別符就不應改變，因為它被許多地方作為參考。這也意味著避免將層次結構關係編碼到識別符中，如果該關係可能會改變。
- **快速且易於產生 (Fast and easy to generate)**：產生識別符的過程應該高效，且性能可預測。
- **不可預測性 (Unpredictable)**：難以預測下一個識別符，這有助於防止攻擊者輕易探測系統中的資源。
- **可讀性、可共享性和可驗證性 (Readable, shareable, and verifiable)**：識別符應該是人類可讀的字串，易於複製和共享，並且可以透過簡單的機制（如校驗碼）進行驗證，以確保其完整性。
- **資訊密度 (Informationally dense)**：雖然識別符應主要用於唯一識別，但它們也可以包含少量有用的中繼資料（例如，資源所屬的集合名稱）。

**識別符的產生和管理：**

1. **誰來產生識別符？** API 服務本身應該負責產生識別符，而不是允許客戶端選擇。客戶端選擇容易導致衝突和不可預測性。
2. **字元集和格式**：

- 應普遍採用 **ASCII** 字元集，以避免 Unicode 編碼和標準化形式帶來的歧義問題。
- 對於公開可見的識別符，建議使用 **Crockford 的 Base32** 編碼。這種編碼將位元組資料轉換為人類可讀且易於使用的字串（不區分大小寫，無歧義字元）。
- 識別符應包含一個 **校驗碼字元**，用於在接收時驗證其完整性，防止輸入錯誤。
- 透過在識別符中「前置」資源的集合名稱（例如 books/abcde-12345），可以增加識別符的資訊密度，使其更容易理解所指向的資源類型。

1. **層次結構與唯一性範圍**：

- 當資源之間存在「擁有權」關係時，應將層次結構關係反映在識別符中（例如 books/1234/pages/5678），這表示子資源僅在其父資源的上下文中存在。
- 每個父資源下的子資源識別符可以獨立重複（例如 books/1/pages/2 和 books/9/pages/2 是兩個不同的識別符）。

1. **大小**：識別符的長度應固定且足夠大，以確保其唯一性（例如，12 或 25 個字元的 Base32 識別符，分別提供約 60 或 120 位元的熵）。
2. **持久性 (Tomb-stoning)**：即使資源被「刪除」，其識別符也不應被重複使用。這可以透過「墓碑 (tomb-stoning)」機制來實現，即將已刪除的識別符儲存在一個列表中，或將資源「軟刪除」而非永久刪除。
3. **與 UUID 的兼容性**：可以將標準的 UUID（通用唯一識別符）與 Crockford 的 Base32 編碼和校驗碼結合使用，以實現全球唯一且易於使用的識別符。
4. **底層儲存**：儘管 API 識別符應以字串形式公開，但在底層資料庫中，可以將其儲存為原始位元組或數據庫優化的數字類型，以提高性能和空間效率。

透過遵循這些指導原則，API 識別符將能夠有效且安全地識別資源，同時為使用者提供良好的開發體驗。

### 7. API 中的「標準方法」是什麼，以及它們有哪些行為特性和限制？

API 中的標準方法（Create、Get、List、Update、Delete）是一組預定義的操作，這些操作被應用於各種資源，以實現一致且可預測的 API 行為。這些方法通常與 RESTful API 中的 HTTP 動詞（POST、GET、PATCH、DELETE）相對應。

**行為特性和限制：**

1. **支援哪些方法？**

- 並非所有資源都必須支援所有標準方法。例如，不可變資源可能不需要 Update 或 Delete 方法。重要的是要有一致的原則來決定哪些方法應該被支援，以及如何處理未支援的方法（例如，返回 HTTP 405 Method Not Allowed 錯誤）。
- **安全性考量**：對於 Get 和 List 這類讀取操作，當使用者無權存取資源時，應該返回 HTTP 403 Forbidden 錯誤，而不是 404 Not Found。這有助於避免未經授權的使用者透過探測來發現存在的資源。

1. **Get 方法**：

- 用於透過唯一識別符檢索特定資源。
- 應始終返回資源的「最新版本」。
- 通常支援「部分檢索」功能，允許客戶端指定只返回資源的特定欄位，以節省頻寬和記憶體。

1. **List 方法**：

- 用於檢索資源集合中的所有資源。
- 應支援「過濾 (filtering)」功能，允許客戶端根據特定條件篩選結果。
- **不應**在回應中包含「結果總數」，因為這會隨著資料量的增長而變得計算密集且不可靠。如果絕對需要，應提供「估計值」並明確命名（例如 resultCountEstimate）。
- **不應**支援「排序 (sorting)」，因為在分散式系統中對大量資料進行全局排序會非常複雜且成本高昂。
- 應支援「分頁 (pagination)」，允許客戶端分塊檢索大量資料，以提高效率。
- **存取控制**：對於部分可存取的集合，應只返回使用者有權存取的項目，且不應因為無權存取某些項目而失敗。

1. **Create 方法**：

- 用於在 API 中建立新資源。
- 通常透過 HTTP POST 方法執行。
- 請求應包含新資源的相關資訊，回應應是新建立的資源。
- **一致性**：建立資源後，應立即能夠透過 Get、List、Update 和 Delete 方法存取該資源（「立即讀取寫入」原則），即使底層儲存系統是最終一致的。這對於 API 的事務行為至關重要。

1. **Update 方法**：

- 用於修改現有資源。
- 應使用 HTTP PATCH 方法，以支援「部分更新」，即只修改請求中明確指定的欄位，而不是替換整個資源。
- 狀態變更不應透過 Update 方法來完成，因為狀態變更通常伴隨「副作用」，這會使 Update 方法的行為變得不可預測。

1. **Delete 方法**：

- 用於從 API 中刪除資源。
- 通常透過 HTTP DELETE 方法執行，並返回空回應（void）。
- **非冪等性**：標準的 Delete 方法不應是冪等性的。換句話說，嘗試刪除一個不存在的資源應該導致失敗（例如 HTTP 404 Not Found），而不是成功（因為沒有東西可刪除）。這允許客戶端區分操作的結果是成功還是已經完成。
- **副作用**：標準刪除方法不應有副作用，例如級聯刪除子資源。這應該由明確的自訂方法處理，或依賴底層儲存系統的行為。

1. **Replace 方法 (半標準)**：

- 類似於 Update，但使用 HTTP PUT 方法。
- 目標是「完全替換」資源，使其看起來與請求中指定的資源完全一致。如果請求中省略了某個欄位，則該欄位在遠端資源上將被清空或設為預設值。

**標準方法的優缺點**：

- **優點**：易於學習、可預測性高，客戶端可以利用現有知識，並在 API 擴展時快速理解新資源。
- **缺點**：強制 API 行為符合狹窄的模式，有時可能無法完美契合所有場景。然而，對於大多數情況，它們能使 API 完成 90% 的工作。

當標準方法無法很好地表達特定行為或需要副作用時，應考慮使用「自訂方法」。

### 8. 什麼時候應該使用「自訂方法」，它們有哪些常見用途和考量？

「自訂方法 (Custom methods)」用於處理那些無法很好地融入標準方法（Create、Get、List、Update、Delete）的特定動作和行為。它們通常用於以下場景和目的：

1. **狀態變更與副作用**：

- 當一個操作不僅僅是更新資源的資料，而是涉及從一個狀態到另一個狀態的「轉換」，並且這種轉換伴隨著「副作用」（例如，發送電子郵件或觸發其他系統操作）時，應該使用自訂方法。
- 例如，發送電子郵件時，使用 SendEmail () 自訂方法比透過 UpdateEmail ({state: 'sent'}) 更能清晰地表達意圖，因為後者隱含了發送郵件的副作用，使標準 Update 方法的行為變得不可預測。
- 標準方法應該是無副作用的，並且其行為應僅限於名稱所暗示的操作。

1. **不適合資源導向的操作**：

- 當操作主要涉及「計算」或「轉化」，而不是對資源進行 CRUD（建立、讀取、更新、刪除）操作時。例如，TranslateText () 或 Factor ()（分解數字）。
- 當操作不需要持久化資料時，例如出於隱私或安全性考慮而不能儲存任何資料的場景。

1. **細粒度權限控制**：

- 如果需要對配置權限和執行權限進行分離，自訂方法可以提供這種彈性。例如，一個自訂方法可能允許某些使用者設定作業的配置，而另一些使用者則僅能執行該作業。

1. **無法透過標準方法實現的複雜邏輯**：

- 雖然理論上可以透過建立額外的「輔助資源」來將任何操作轉換為標準方法，但這往往會導致過度複雜的資源模型，降低 API 的直觀性和可用性。在這種情況下，自訂方法是更務實的選擇。

**自訂方法的常見用途和考量：**

- **HTTP 動詞**：自訂方法幾乎總是使用 **HTTP POST** 動詞。它可能在極少數情況下使用 GET（如果它是冪等且安全的），但通常不應使用 PATCH 或 DELETE。
- **URL 格式**：自訂方法使用「冒號 (:)」作為分隔符，將資源目標與自訂動作分開（例如 /rockets/1234:launch）。這可以避免與標準資源子集合的路徑混淆。
- **目標**：
- **資源導向**：自訂方法可以針對單個資源（例如 /users/1:export 用於匯出單個用戶的所有資訊）。
- **集合導向**：當涉及同一集合中的多個資源時，通常更適合針對集合本身（例如 /users/-/emails:archive 用於歸檔多個用戶的多封郵件）。
- **無狀態方法**：對於純粹的計算或不需要任何狀態的方法，可以沒有資源或集合作為目標。然而，通常會將其錨定在一個計費或權限容器資源下（例如 /projects/1:translateText）。
- **冪等性**：自訂方法可以設計為冪等的，以便客戶端在網路不穩定時安全地重試。
- **輸出**：自訂方法的回應可以是任何類型，包括新的資源、修改過的資源，甚至是長時間執行的操作 (LRO) 資源。對於無狀態操作，通常返回 void（空回應）。
- **長時間執行操作 (LRO)**：如果自訂方法可能需要很長時間才能完成，則應返回一個長時間執行操作 (LRO) 資源，以便客戶端可以追蹤進度和結果。

總之，自訂方法是標準方法的重要補充，它們填補了標準方法在表達特定行為和處理副作用方面的空白，使 API 更加靈活和實用。然而，它們應謹慎使用並充分記錄，以避免造成混淆。