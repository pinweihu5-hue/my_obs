---


---

### 主要主題與重要概念

#### 1. API 的本質與「良好」API 的特徵

- **什麼是網路 API？** 網路 API 是「定義電腦系統如何互動」的介面，特別指那些「透過網路公開並供多人遠端使用」的介面。與函式庫不同，網路 API 的變更會直接強制於使用者，因此其設計者擁有完全的控制權，但也帶來了兼容性挑戰。它們能夠「公開功能，同時隱藏計算需求」，例如機器學習 API。
- **API 的重要性：** API 透過提供電腦所需的語言，實現了自動化與組合性，使功能如同「樂高積木」般組裝，創造出比各部分總和更強大的新應用。
- **資源導向 API (Resource-Oriented APIs)：** 這種設計風格強調「資源」（API 管理的關鍵概念）和「標準方法」（對資源執行的操作）。例如，航班預訂 API 不再使用 RescheduleFlight () 或 CancelReservation () 等多樣化的 RPC 名稱，而是對單一資源如 FlightReservation 應用標準方法：CreateFlightReservation ()、GetFlightReservation ()、ListFlightReservations ()、DeleteFlightReservation ()、UpdateFlightReservation ()。這種標準化「使得 API 更易於學習、理解和記憶」。
- **「良好」API 的特徵：可操作性 (Operational)：** API 必須實際執行使用者想要的功能，並滿足非操作性需求如延遲和準確性。
- **表達性 (Expressive)：** 介面應允許使用者「清晰、簡單地表達他們想要做的事情」。避免隱藏功能導致使用者需要「變通方法」來實現目的。例如，提供 DetectLanguage () 而非要求使用者透過 TranslateText () 來猜測語言。
- **簡潔性 (Simple)：** API 應「盡可能簡單，但不能再簡單」。應使「常見情況變得出色，進階情況變得可能」，將複雜性隱藏起來，避免常用場景變得複雜。
- **可預測性 (Predictable)：** API 應保持一致性，遵循「相同的名稱代表相同的事物，不同的名稱代表不同的事物」的原則。這使得使用者能夠依據已學知識推斷未來行為，避免因不一致而「生產力停滯」。

#### 2. API 設計模式的價值與結構

- **什麼是 API 設計模式？** 它們是「軟體設計模式應用於 API」，是「設計和建構 API 的藍圖」，關注於介面而非底層實作。它們提供「預先設計的構建模塊」，可重複應用於類似問題。
- **為何重要？** API 通常「非常『僵硬』且不易更改」，特別是在共享給全球使用者時。迭代開發方法（如敏捷）在 API 設計中難以應用，因為變更可能導致現有程式碼中斷。設計模式有助於「第一次就做對」，而非事後修補。
- **模式的構成：動機 (Motivation)：** 解釋模式要解決的根本問題，包括使用者目標和邊緣情況。
- **概述 (Overview)：** 提供解決方案的高層次描述，包括組件及其職責。
- **實作 (Implementation)：** 最重要的部分，提供「介面定義」，展示 API 如何使用此模式。
- **權衡 (Trade-offs)：** 討論使用此模式的優缺點。

#### 3. 命名原則 (Naming)

- **重要性：** 「API 中無處不在的名稱」將比預期存在更久，因此選擇好名稱至關重要，並「應避免更改」公開名稱。
- **「良好」名稱的特徵：** 簡潔、表達性和可預測性。
- **語言、語法和語法：語言：** 建議使用「美式英語」，以實現「最大互操作性」。
- **動詞語態：** 避免模棱兩可的動詞語態（如 isValid ()），偏好更清晰的命令式動詞（如 GetValidationErrors ()）。
- **介詞：** 名稱中的介詞（如 BookWithAuthor）常是「API 異味」，暗示可能存在更深層的設計問題，應考慮使用「欄位遮罩 (field mask)」或「視圖 (view)」。
- **複數形式：** 在集合名稱（如 URL）中使用複數形式，但資源名稱本身通常為單數。需注意不規則複數（如 Foot 到 Feet，Person 到 People）。
- **命名慣例 (Case)：** 針對資源、RPC 和欄位使用不同的命名慣例（如 UserSettings 使用大駝峰式，first_name 使用蛇形命名，firstName 使用小駝峰式）。
- **保留字：** 避免使用程式語言的「保留關鍵字」作為 API 名稱。
- **上下文 (Context)：** 名稱的含義常依賴於其使用上下文。API 設計者應意識到上下文可能帶來的含義。
- **資料類型與單位 (Data Types and Units)：** 在名稱中包含單位（如 sizeBytes、sizeMegapixels）可使欄位意義更明確。應優先使用「更豐富的資料類型」而非原始字串來表達複雜概念（如 Dimensions 介面包含 lengthPixels 和 widthPixels）。

#### 4. 資源範圍與層次結構 (Resource Scope and Hierarchy)

- **資源佈局 (Resource Layout)：** 指 API 中資源的排列方式、定義資源的欄位以及資源之間如何透過這些欄位相互關聯。
- **關係類型：參考關係 (Reference Relationships)：** 一個資源透過識別碼指向另一個資源。
- **階層關係 (Hierarchical Relationships)：** 親子資源之間的特殊參考關係，通常涉及「級聯效應」和「繼承行為與屬性」（例如，刪除父資源會刪除子資源，父資源的存取權限適用於子資源）。
- **多對多關係 (Many-to-Many Relationships)：** 兩個資源類型之間相互關聯（如使用者與群組）。
- **自引用關係 (Self-Reference Relationships)：** 資源指向相同類型的其他資源。
- **選擇正確的關係：是否需要關係？** 避免將所有可能相關的事物都連接起來，僅在提供重要功能時才建立關係。
- **值與參考 (Value vs. Reference)：** 內聯數據（即直接將相關資源的資訊嵌入）可減少 API 調用次數，但可能增加數據大小和複雜性。參考則反之。應「優化常見情況，同時不損害進階情況的可行性」。
- **階層：** 階層關係非常有用，但應「避免過深的階層」，因為它們會使理解和管理變得困難。
- **反模式 (Anti-patterns)：萬物皆資源 (Resources for everything)：** 避免將每個概念都變成獨立的資源，只有當需要「獨立操作」時才使其成為資源。
- **過深階層 (Deep hierarchies)：** 避免建立過於複雜的階層結構，僅保留那些真正從階層中受益的部分。
- **全部內聯 (In-line everything)：** 避免將過多資訊內聯到單一資源中，特別是當數據會被多個資源共享時，可能導致數據一致性問題。

#### 5. 資料類型與預設值 (Data Types and Defaults)

- **資料類型：** API 設計者需要根據選定的序列化格式（通常是 JSON）來考慮資料類型，並在必要時進行擴展。
- **缺失與空值 (Missing vs. null)：** 許多序列化格式支援 null 值，但 API 需要明確定義如何處理缺失（未提供）或 null 值。
- **布林值 (Booleans)：** 適合用於旗標，但當問題變得更複雜時可能限制未來彈性。建議使用「正向布林旗標」（如 allowChatbots）而非負向（如 disallowChatbots），因為前者「對於大多數人來說更容易理解」。
- **數字 (Numbers)：** 適合用於提供算術意義的值。**不應**用於數字識別碼，因為其通常無算術意義。在 API 表面，數字識別碼應使用字串。
- **邊界 (Bounds)：** 定義數字欄位的最大值和最小值。為確保跨語言和系統兼容性，建議「依賴 64 位整數類型」作為預設。
- **序列化：** 由於浮點數精度問題和不同語言對大數字的處理方式不同，建議將「數字值序列化為字串值」以避免問題。
- **字串 (Strings)：** 最常用和多功能的資料類型，可用於文本內容、長文本塊，甚至編碼的二進制數據。也「最適合用於儲存唯一識別碼」。
- **邊界 (Bounds)：** 定義字串的最大長度。超出限制的輸入應被「拒絕」而非截斷，以避免誤導和不一致。
- **序列化：** 建議使用 UTF-8 編碼。對於識別碼，應確保使用「Unicode 標準化形式 C (Normalization Form C)」以避免「因位元組表示問題而導致重複鍵值」。
- **列舉 (Enumerations)：** 應「普遍避免」，改用字串值並在伺服器端進行驗證，特別是當預期會增加新值時。列舉可能導致客戶端需要更新才能識別新值，而字串則更具彈性。
- **列表 (Lists)：** 適用於代表 API 資源固有屬性的簡單原始集合。
- **原子性 (Atomicity)：** 列表欄位應被視為「原子數據塊」，整體修改和替換，不應支援部分更新（如修改列表中特定位置的項目）。
- **邊界：** 列表應設有項目數量上限和每個項目的大小限制。
- **映射 (Maps)：** 最多功能的資料類型，可分為「自訂資料類型」（預定義模式）和「動態鍵值映射」（任意鍵值對）。
- **自訂資料類型：** 將相關欄位分組（如 SecurityConfig）。
- **動態鍵值映射：** 適用於動態設定或依賴於特定資源實例細節的配置（如 ingredientAmounts）。
- **邊界：** 動態映射應定義鍵值對的數量上限，以及每個鍵和值的字串大小限制。

#### 6. 資源識別 (Resource Identification)

- **識別碼 (Identifiers)：** 用於「唯一指向 API 中特定資源」的值。
- **良好識別碼的特徵：易於使用 (Easy to use)：** 直觀且易於處理。
- **唯一性 (Unique)：** 確保每個資源都有獨一無二的識別碼。
- **永久性 (Permanent)：** 識別碼「永遠不應被重用」，即使在資源被刪除後。這有助於避免歧義並確保引用的一致性。
- **快速且易於生成 (Fast and easy to generate)：** 生成識別碼的過程應高效且具可預測的性能。
- **不可預測性 (Unpredictable)：** 應難以預測下一個識別碼，以提升安全性。
- **可讀、可複製、可分享、可驗證 (Readable, copyable, shareable, and verifiable)：** 識別碼應便於人類讀取、複製和分享，並能透過校驗和等機制驗證其有效性。
- **資訊密度 (Informationally dense)：** 識別碼可以包含資源類型等有用資訊。
- **實作：字串作為識別碼：** 即使看起來像數字，也應將識別碼表示為字串，因為它們「行為更像記號或符號」。
- **字元集：** 建議使用 **ASCII** 以避免 Unicode 標準化形式帶來的歧義。
- **URI 安全字元：** 考慮使用 URI 安全字元集，以便識別碼能輕鬆整合到 URL 中。
- **基底 32 (Base32) 編碼：** 建議使用 Crockford 的 Base32，因其具有「高度可讀性」和「內建校驗和」功能。
- **類型前綴：** 透過前綴（如 books/）將識別碼與其集合名稱關聯，方便識別資源類型。
- **階層與唯一性範圍：** 階層關係應表達「所有權」而非僅「關聯性」。子資源的識別碼應包含父資源的識別碼，例如 books/1234/pages/5678。
- **大小：** 應選擇固定長度的識別碼。對於單一資源類型內唯一，建議使用 64 位整數對應的 13 個 Base32 字元；對於全球唯一，建議使用 128 位 UUID 對應的 25 個 Base32 字元。
- **生成來源：** 識別碼應由「API 服務」生成，而非使用者選擇，以避免衝突和混淆。
- **隨機數生成器：** 使用密碼學安全的隨機位元組生成器。
- **墓碑 (Tomb-stoning)：** 即使資源被刪除，其識別碼也應保留在「墓碑」中，以確保「永遠不會被重用」。
- **校驗和 (Checksums)：** 將校驗和字元附加到識別碼末尾，用於「驗證其有效性」。
- **儲存：** 識別碼應以原始位元組形式儲存於資料庫中，而校驗和字元則在顯示時動態生成。
- **UUIDs (Universally Unique Identifiers)：** 本書推薦的設計與 UUID 兼容，可透過將 UUID 轉換為 Base32 編碼來使用。

#### 7. 標準方法 (Standard Methods)

- **動機：** 透過標準化一組操作（方法），使使用者能「更快地理解 API 的運作方式」，因為他們可以將已有知識應用到新資源上。
- **概述：** API 應提供一組「標準動作」（通常是 CRUDL：Create, Read (Get / List), Update, Delete）以作用於其資源。
- **實作：支援哪些方法？** 並非所有資源都必須支援所有標準方法（例如，不可變資源可省略 update）。
- **Get：** 透過唯一識別碼檢索單一資源。應處理未找到和無權限的情況（建議針對無權限的資源返回 404 而非 403，以避免資訊洩露）。
- **List：** 檢索資源集合。
- **存取控制：** 應僅返回使用者有權存取的項目。
- **結果計數：** 通常不建議在 List 方法的回應中包含確切的項目計數，因為這在大型分散式系統中可能成本高昂。若必須提供，應標示為「估計值」。
- **排序：** 通常不鼓勵，因為在分散式系統中實現全局排序可能非常複雜且耗時。
- **過濾 (Filtering)：** 建議支援，透過字串形式的過濾條件，由伺服器端應用。
- **Create：** 建立新資源。回應應為新建立的資源。
- **識別碼：** 識別碼應由伺服器生成，而非客戶端提供，以避免衝突。
- **一致性 (Consistency)：** 應實現「強一致性」，即「一旦 API 聲明已建立資源，該資源應在所有意義上都已建立，並可供所有其他標準方法使用」。避免最終一致性導致「寫後不一致」問題。
- **Update：** 更新現有資源。通常使用 HTTP PATCH 方法進行「部分修改」，而非完全替換。
- **Delete：** 移除資源。通常返回空回應 (void)。
- **冪等性 (Idempotence)：** 標準 Delete 方法應是「非冪等的」，即嘗試刪除不存在的資源應導致失敗（與 REST 規範的預期行為不同）。
- **Replace (半標準方法)：** 類似 Update，但使用 HTTP PUT 方法，旨在「完全替換」資源，清除任何未包含在請求中的欄位。
- **權衡：** 標準方法雖然限制了行為，但換來了「易於學習的 API」，使用者可以利用對資源導向 API 的既有知識，從而「有效倍增其知識」。

#### 8. 部分更新與檢索 (Partial Updates and Retrievals)

- **動機：部分檢索：** 當資源「非常大」或客戶端設備資源有限（如 IoT 設備）時，只檢索資源的特定部分有助於節省成本、頻寬和記憶體。
- **部分更新：** 為了「更精細地控制」特定欄位的修改，避免「數據丟失」（例如，當客戶端不知道新添加的欄位時，完全替換可能覆蓋這些欄位）。它允許 API 消費者「更具體地表達其意圖」。
- **概述：** 透過「欄位遮罩 (Field Mask)」工具實現，它是一個字串集合，代表感興趣的欄位列表。對於 PATCH 請求，若未明確提供欄位遮罩，可從 JSON 物件中推斷。
- **實作：傳輸：** 欄位遮罩在 GET 請求中作為「查詢參數」，在 PATCH 請求中則作為「請求介面上的欄位」。
- **映射與巢狀介面 (Maps and nested interfaces)：** 支援對巢狀結構中的個別欄位進行尋址（例如 loggingConfig.maxSizeMb），對於映射，使用反引號引用鍵（例如 settings.\test.value``）。
- **重複欄位 (Repeated fields)：** **不應**支援透過索引來尋址列表中個別項目。應將整個重複欄位視為原子單位進行替換。
- **預設值：** GET 請求的預設欄位遮罩應包含資源上所有可用的欄位。
- **隱式欄位遮罩 (Implicit Field Masks)：** PATCH 請求中，如果未提供欄位遮罩，可以從請求體中提供的欄位推斷。
- **更新動態資料結構 (Updating dynamic data structures)：** 可透過在欄位遮罩中包含一個鍵但不在請求體中提供其值來「刪除」映射中的鍵。
- **無效欄位 (Invalid fields)：** 當欄位遮罩中指定的欄位不存在時，應將其值視為 undefined 並忽略，而非拋出錯誤，以避免因版本演進導致的客戶端問題。
- **權衡：** 部分更新是標準更新方法的「硬性要求」，但部分檢索並非必需，應根據資源大小和複雜性決定。如果支援部分檢索，應在所有資源上提供，以保持一致性。

#### 9. 自訂方法 (Custom Methods)

- **動機：** 當標準方法「感覺不太對勁」或無法很好地表達特定動作時（例如，狀態變更或伴隨「副作用」的操作，如發送電子郵件）。標準方法應避免副作用，但自訂方法允許。
- **概述：** 自訂方法是「非標準的 API 調用」，用於執行特定動作。它們通常與資源或集合相關聯。
- **實作：HTTP 方法：** 通常使用 **HTTP POST** 方法。
- **URL 格式：** 使用「冒號（:）」字元分隔資源目標和動作名稱（例如 POST /rockets/1234567:launch）。
- **資源與集合：** 當操作涉及「多個相同類型的資源」時，通常應針對「集合」進行操作（例如 POST /users/1/emails:export）。
- **無狀態自訂方法 (Stateless Custom Methods)：** 用於無需處理任何狀態且無需與資源或集合關聯的操作（如純計算）。但通常會錨定到一個父資源作為權限或計費容器。
- **權衡：** 自訂方法是標準方法的「補充」，使 API 在非標準互動上更具彈性。然而，應「謹慎使用」並「徹底記錄」，以避免使用者混淆。

#### 10. 長時間運作的操作 (Long-Running Operations, LROs)

- **動機：** 當 API 方法「不是瞬時的」或可能需要很長時間才能完成時，標準的同步請求 / 回應模式不再適用。LROs 允許 API 方法以「非同步方式」運行，並提供快速一致的反饋。
- **概述：** LROs 是一種「網路 API 的 Promises 或 Futures」，代表正在後台執行的工作。它們作為 API 方法的新回傳類型。
- **生命週期：** LROs 從發起、進行中到完成（成功或失敗）的過程。
- **目標：** LROs 應作為「集中式頂級集合」的資源（例如 /operations/1），以便於發現和管理。
- **實作：Operation 介面：** 定義 LRO 資源的結構，包含 id、done 狀態、result (最終結果或錯誤) 和 metadata (進度等資訊)。
- **解析 (Resolution)：** 客戶端透過「輪詢 (polling)」GetOperation 方法或使用「阻塞式請求 (blocking requests)」WaitOperation 來獲取 LRO 的狀態和結果。
- **錯誤處理：** LRO 結果中的錯誤應包含機器可讀的 code 和人類可讀的 message。
- **進度監控：** 透過 metadata 欄位提供進度指示器（如 progressPercent）。
- **取消操作：** 提供 CancelOperation 自訂方法來請求停止正在執行的 LRO。
- **探索操作：** 透過 ListOperations 方法發現系統中所有已知的 LROs。
- **持久性 (Persistence)：** LRO 資源應持久化儲存，但通常應在「標準期限後（如 30 天）」過期，以避免無限制的儲存成本。
- **權衡：** LROs 解決了長時間操作的複雜性，但引入了額外的 API 複雜性（如輪詢機制）。然而，它使 API 具有高度可擴展性和可監控性。

#### 11. 可重執行作業 (Rerunnable Jobs)

- **動機：** 當 API 需要暴露可配置、可重複執行的功能時（如定期備份或分析任務），且：
- 每次調用都提供所有配置參數會很麻煩。
- 需要將配置權限與執行權限分離。
- 希望 API 服務能夠自動調度執行，而非依賴客戶端排程。
- **概述：** 將「按需調用」的 API 方法分解為兩個部分：建立一個儲存配置的「作業 (Job)」資源，然後透過其自訂的「運行 (Run)」方法來觸發實際工作。
- **實作：Job 資源：** 儲存配置參數，支援標準方法（Get, Create, Update, Delete, List）。
- **Run 自訂方法：** 觸發作業執行，應返回一個 LRO，且「不應在執行時傳遞任何額外配置」。
- **作業執行資源 (Job Execution Resources)：** 如果作業的結果沒有持久的副作用或其持久性策略與 LRO 不同，則可定義 Execution 資源來表示單次運行結果，並作為作業資源的子集合。
- **權衡：** 可重執行作業提供了一種標準化的方式來管理可配置和可調度的任務，但也增加了 API 的資源數量和複雜性。

#### 12. 單例子資源 (Singleton Sub-Resources)

- **動機：** 當資源的某些組成部分：
- 獨立於父資源變化（Volatility）。
- 具有不同的安全要求（Security）。
- 過大而無法直接儲存為屬性（Size）。
- 例如，駕駛員的即時位置資訊，其更新頻率遠高於駕駛員的其他靜態資訊。
- **概述：** 單例子資源是「屬性與完整資源之間的混合體」，每個父資源只有一個此類子資源（例如 /drivers/1/location）。它允許對特定數據集合進行獨立的存取、更新和安全控制。
- **實作：行為：** 對於 Get 和 Update 方法，其行為類似於獨立資源，透過唯一識別碼尋址。但 Create 和 Delete 方法的行為則更像屬性。
- **創建：** 單例子資源「不被明確創建」，而是隨父資源的創建而「隱式存在」。因此，需要為其設定合理的預設值。
- **刪除：** 應支援 Reset 自訂方法來將其內容重置為預設狀態，而非 Delete 方法（因為它總是存在）。
- **階層：** 單例子資源「不應」再有自己的單例子資源。
- **原子性：** 一個重要的權衡是，它「不再能夠原子性地同時與父資源和子資源互動」。

#### 13. 交叉引用 (Cross References)

- **動機：** 資源之間需要相互引用，可能是同一個 API 內，也可能是外部 API。
- **概述：** 透過資源上的「參考屬性」，使用字串形式的「唯一識別碼」來指向另一個資源。欄位名稱應暗示被參考資源的類型和目的（如 authorId）。
- **實作：數據完整性：** 由於參考是簡單字串，存在「懸空指針 (dangling pointer)」的風險（參考的資源已被刪除）。API 應允許這種情況，並要求客戶端檢查參考的有效性，而不是由 API 強制維護引用完整性（這可能導致「寫入雪崩」或「刪除循環」）。
- **值與參考：** 應根據「常見查詢模式」來決定是內聯數據還是使用參考。內聯數據減少 API 調用，但可能增加數據大小和一致性複雜性。
- **權衡：** 依賴參考可能需要「多次 API 調用」來獲取相關資訊，或需要使用 GraphQL 等工具來解決此問題。

#### 14. 關聯資源 (Association Resources)

- **動機：** 處理「多對多關係」，其中兩個資源類型都相互擁有許多對方（如使用者和群組）。此外，可能需要儲存關於關係本身的「特定元數據」（如加入時間、角色）。
- **概述：** 將關係本身表示為一個「實際的資源」（如 UserGroup 或 Membership），它連結兩個相關資源並可儲存關係元數據。
- **實作：命名：** 應選擇一個清晰的名稱來表示兩個資源的關聯（如 UserGroup 或 Membership）。
- **標準方法行為：** 關聯資源應支援標準方法（Create, Get, List, Delete, Update）。
- **唯一性：** 對於兩個被關聯的資源，應只存在一個關聯資源（例如，一個使用者只能在一個群組中一次）。
- **只讀欄位：** 被關聯的資源識別碼（如 userId, groupId）在關聯資源的生命週期內應為只讀，不允許修改。
- **關聯別名方法 (Association Alias Methods)：** 可提供自訂的 List 方法來簡化常見查詢，例如 ListUserGroups () 或 ListGroupUsers ()。
- **引用完整性：** 建議當關聯資源引用的資源被刪除時，「不對關聯資源做任何處理」，讓其成為懸空指針，並讓客戶端負責處理。
- **權衡：** 關聯資源提供了最大的「靈活性」來設計關係細節，但增加了 API 的「複雜性」（引入了第三個資源類型），並可能導致關係與被關聯資源的分離。

#### 15. 新增與移除自訂方法 (Add and Remove Custom Methods)

- **動機：** 作為多對多關係的「簡化替代方案」，當「無需儲存關係元數據」時。
- **概述：** 透過自訂的 add 和 remove 方法隱式地管理關係，完全「隱藏關聯資源」，只關心關係是否存在。
- **限制：** 無法儲存關係元數據。需要選擇一個「管理資源」，將 add 和 remove 方法附加到該資源上。
- **實作：列出關聯資源：** 透過自訂的 List 方法（如 ListGroupUsers () 和 ListUserGroups ()）來列出關聯資源。
- **數據完整性：** 嘗試添加已存在的關係應返回 409 Conflict 錯誤；嘗試移除不存在的關係應返回 412 Precondition Failed 錯誤。
- **權衡：** 簡化了 API（無須額外資源），但犧牲了「關係元數據」的儲存能力，並引入了「非互惠關係」（需要選擇管理資源）。

#### 16. 多態性 (Polymorphism)

- **動機：** 當多個資源具有共同的性質（如 TextMessage, PhotoMessage 都是 Message），但在內容上有所不同時。其目的是「避免重複共享功能」。
- **概述：** 資源本身具有一個 type 欄位來指示其具體類型，並據此解釋其內容。
- **實作：決定何時使用：** 當使用者「合理地期望能夠同時列出多種類型的資源」時（例如，列出聊天室中的消息），多態性是合適的。
- **結構：定義類型欄位：** 使用簡單的「字串欄位」來儲存類型，而非列舉，以提升彈性。
- **儲存數據：** 可以使用一個「包含所有可能欄位的超集」介面，或者使用「單一欄位但其類型依賴於 type 欄位」。後者更具彈性。
- **行為：** 多態資源上的方法應與普通資源行為一致，其行為差異由 type 欄位決定。
- **為何不應有「多態方法」？** 應避免單一方法能操作多種不同資源類型，因為這會導致方法行為複雜且不易理解。
- **權衡：** 多態性是強大工具，但也可能複雜。應謹慎使用，因為它會將資源鎖定在特定表示中，未來難以非破壞性地解耦。

#### 17. 複製與移動 (Copy and Move)

- **動機：** 資源的「永久性」雖重要，但在現實中，使用者仍需要「複製 (duplication)」或「移動 (relocation)」資源（例如，重新命名或變更父資源）。
- **概述：** 透過自訂的 copy 和 move 方法來實現這些操作，它們比透過標準 update 和 create 方法的組合更安全、更穩定。
- **實作：識別碼：** 複製操作應「類似於標準 create 方法」的識別碼生成策略（服務生成或使用者指定）；移動操作則涉及更改現有識別碼。
- **子資源：** 複製或移動父資源時，「應一併複製或移動」其所有子資源，以確保新目標資源與源資源行為相同。
- **相關資源：** 對於引用目標資源的其他「相關資源」，應考慮如何處理（如更新其引用或特定場景下不複製）。
- **外部數據：** 應明確複製是「按參考複製」還是「按值複製」。建議採用「寫時複製 (copy on write)」策略。
- **繼承元數據：** 移動的資源應「繼承新父資源的元數據和規則」。若違反規則，應拒絕操作。
- **原子性：** 複製和移動操作應「盡可能原子性」，確保所有相關操作要麼全部成功，要麼全部失敗，尤其是在數據集活躍變動時。
- **權衡：** 這些操作可能比預期更複雜且資源密集。複製功能通常非常有價值，但移動功能應謹慎考慮，因為它常常暗示了「資源佈局不佳」或「識別碼選擇不當」。

#### 18. 批次操作 (Batch Operations)

- **動機：** 當需要「同時操作多個資源」並需要「原子性」時。例如，同時更新兩個資源，且這兩個更新要麼都成功，要麼都失敗。
- **概述：** 提供「批次版本的標準方法」（BatchGet、BatchCreate、BatchUpdate、BatchDelete），以實現多資源操作的原子性。
- **實作：原子性：** 「所有批次方法都必須完全原子性」。
- **針對集合操作：** 批次方法應「針對集合」進行操作，其 URL 應以 `:batch<Method>` 結尾。
- **結果順序：** 批次方法返回的資源「必須」與請求中提供的順序相同。
- **共同欄位 (Common Fields)：** 可將批次請求中多個子請求的共同欄位「提升」到批次請求層級，以減少重複。若提升欄位與子請求欄位衝突，應拒絕請求。
- **跨父資源操作：** 透過在父資源位置使用「萬用字元（-）」來表示操作可以跨越多個不同的父資源。
- **BatchGet：** 透過 ID 列表獲取多個資源，支持部分檢索。
- **BatchDelete：** 透過 ID 列表刪除多個資源。
- **BatchCreate：** 建立多個資源，請求中包含標準 Create 請求列表。
- **BatchUpdate：** 更新多個資源，請求中包含標準 Update 請求列表，支持部分更新。
- **權衡：** 批次操作將「原子性置於一切之上」，這在某些常見情況下可能帶來不便（例如，刪除多個資源時，若其中一個已刪除，則整個操作失敗），但確保了事務語義。設計上強調簡潔性，即使有時犧牲了輸入格式的一致性。

#### 19. 基於條件的刪除 (Criteria-Based Deletion)

- **動機：** 當需要「根據一組過濾條件刪除多個資源」時，而不能僅靠提供明確的 ID 列表。傳統方法（先 List 再 BatchDelete）會導致非原子性問題。
- **概述：** 引入自訂的「清除 (Purge)` 方法，允許透過過濾條件原子性地刪除資源。
- **實作：過濾結果：** Purge 方法的過濾欄位應與標準 List 方法行為「完全相同」。
- **預覽模式：** Purge 方法預設為「預覽模式」，只顯示將被刪除的資源數量和樣本，而不實際執行刪除。使用者需設定 force 旗標為 true 才能實際執行刪除。
- **結果樣本集 (Result Sample Set)：** 預覽模式應提供「將被刪除資源的識別碼樣本」，供使用者確認。
- **權衡：** 提供了原子性的條件刪除能力，但增加了複雜性，並且由於預覽模式和實際執行分離，可能帶來一些誤解。

#### 20. 匿名寫入 (Anonymous Writes)

- **動機：** 當數據需要被寫入，但「事後無需唯一識別」（例如日誌條目、時間序列數據點用於聚合統計），且數據「無法被單獨檢索、更新或刪除」。
- **概述：** 透過自訂的 write 方法將數據插入 API，但結果數據是「匿名的」，只能透過「聚合方式」進行探索。
- **實作：回傳類型：** write 方法應回傳 void（空值），因為沒有資源可回傳。
- **一致性：** 允許「最終一致性」。即，write 方法可以立即返回成功，即使數據尚未對其他 API 方法可見。
- **URL 綁定：** write 方法應針對「集合」進行操作，其 URL 類似於 /chatRooms/1/statEntries:write。
- **權衡：** write 方法主要用於分析數據攝取，填補了傳統資源導向設計在處理此類數據方面的空白。

#### 21. 分頁 (Pagination)

- **動機：** 當資源數量或單一資源的大小「過於龐大」而無法透過單一 API 回應傳輸時，需要一種機制來分塊消費數據。
- **概述：** 允許客戶端「每次請求一小塊數據」，API 回應相應的數據塊和一個指向下一塊的「不透明頁面令牌 (opaque page token)」。
- **實作：pageToken：** 作為「游標」，指示從何處繼續。當無更多結果時，應回傳「空頁面令牌」。
- **maxPageSize：** 客戶端期望的最大結果數。建議將其定義為「最大數量」而非精確數量，因為在分散式系統中，精確填充頁面可能導致性能問題。
- **預設值：** 建議預設頁面大小為 10。
- **上下限：** 應限制頁面大小的合理範圍。
- **totalCount：** 通常不建議包含，但在某些情況下，可提供「預估總數」。
- **資源內分頁：** 對於單個大型資源內部的數據（如附件），也可採用分頁。
- **權衡：** 分頁解決了大型數據集的消費問題，但「不支持雙向分頁」。

#### 22. 過濾 (Filtering)

- **動機：** 當需要「根據特定條件瀏覽資源」時，而不是獲取所有資源然後在客戶端篩選。將過濾責任推到「API 服務器端」。
- **概述：** 透過在 List 方法中包含一個「過濾表達式」來實現。
- **實作：結構：** 建議使用「字串形式的過濾表達式」（類似 SQL 的 WHERE 子句）而非結構化介面，因為它更具彈性且與程式語言中的布林表達式相似，對使用者更為熟悉。
- **語法與行為：執行時間：** 過濾器應「僅需要單一資源的上下文」進行評估，避免涉及昂貴的外部系統調用。
- **陣列索引尋址：** 不應支援透過陣列索引尋址列表中的單個值進行過濾，因這暗示了列表順序是靜態的，難以維護。
- **嚴格性 (Strictness)：** 應在過濾表達式中「嚴格處理錯誤」，例如，當欄位引用無效時應拋出錯誤，而非靜默忽略。
- **函數調用：** 可透過提供「特殊函數調用」來支持更複雜的過濾需求（如 endsWith ()、imageContains ()）。
- **權衡：** 伺服器端過濾大大提高了效率，但需要仔細定義過濾語法和功能範圍，以平衡靈活性和複雜性。

#### 23. 導入與導出 (Importing and Exporting)

- **動機：** 當需要「安全、靈活地將資源移入和移出 API」時，且數據量龐大，透過客戶端作為中間人傳輸效率低下。API 應「直接與外部儲存系統通訊」。
- **概述：** 透過自訂的 import 和 export 方法實現，它們接收配置結構，用於數據轉換和數據傳輸。
- **實作：方法：** import 和 export 方法應返回 LRO，因為它們可能需要很長時間。
- **與儲存系統互動：** 定義獨立的配置介面 (DataSource, DataDestination) 用於外部儲存系統的連接，以及 MessageInputConfig, MessageOutputConfig 用於數據格式轉換。
- **數據一致性：** 導入 / 導出操作可能導致「數據塗抹 (smear of data)」，即數據在操作過程中不保持一致快照。這在大型分散式系統中是常見的權衡。
- **與備份 / 恢復的區別：** 導入/導出「不是」備份/恢復的機制。備份/恢復對數據一致性有更嚴格的保證。
- **處理相關資源：** 導入 / 導出通常應「僅限於單一資源類型」，不應自動包含子資源或相關資源，因為這會使操作複雜化並偏離其核心目的。
- **故障與重試：** 導出故障通常是安全的重試。導入故障則較複雜，可能需要請求去重或使用數據庫事務。
- **權衡：** 導入 / 導出模式專注於 API 服務與外部儲存系統之間的直接數據傳輸，具有高特異性和狹窄的焦點，這帶來了無法處理複雜關係和數據一致性挑戰的限制。

#### 24. 版本控制與兼容性 (Versioning and Compatibility)

- **概述：** 透過引入「檢查點」或「版本」，維護 API 的獨立部署，以確保「現有使用者不受後續變更的影響」。
- **兼容性 (Compatibility)：** 如果新版本可以替換舊版本，且現有客戶端程式碼「不會注意到差異或停止運行」，則兩個 API 服務版本兼容。
- **向後兼容性 (Backward Compatibility)：** 變更不會破壞現有程式碼。這是 API 設計中「沒有單一正確答案」的複雜領域，很大程度上取決於 API 使用者的期望。
- **新功能：** 新增欄位或資源通常是向後兼容的，但可能影響資源受限的客戶端（如 IoT 設備）。
- **錯誤修復：** 讓 API 調用突然開始拋出錯誤通常不是好主意。更微妙的修復（如浮點數精度）取決於錯誤的影響。
- **底層變更：** 性能優化或機器學習模型變更可能影響使用者，即使回應本身未變。
- **語義變更：** API 中概念含義的改變是最廣泛也最微妙的向後不兼容變更。
- **實作：永久穩定性 (Perpetual stability)：** 意外導致的策略，即只在不得不進行向後不兼容變更時才創建新版本（v1 -> v2）。通常導致版本發布較慢但單一版本生命週期長。
- **敏捷不穩定性 (Agile instability)：** 鼓勵快速迭代，將 API 版本分為「預覽 (Preview)」和「目前 (Current)」。預覽版本鼓勵嘗試新功能，但不保證穩定性；目前版本則只允許強制性變更和關鍵錯誤修復。
- **語義版本控制 (Semantic Versioning, SemVer)：** 採用 MAJOR.MINOR.PATCH 格式。
- MAJOR：向後不兼容的 API 變更。
- MINOR：向後兼容的功能性新增。
- PATCH：向後兼容的錯誤修復。
- **權衡：粒度與簡潔性：** 版本數量與管理複雜性之間的權衡。
- **穩定性與新功能：** 越強調穩定性，新功能推出越慢。
- **用戶滿意度與普遍性：** 滿足所有使用者期望的難度，因為不同使用者有不同的需求。

#### 25. 軟刪除 (Soft Deletion)

- **動機：** 當需要「標記資源為『已刪除』但仍可恢復」時，作為硬刪除的替代方案（類似電腦的「資源回收桶」）。這在防止意外數據丟失時尤其重要。
- **概述：** 在資源上儲存一個「已刪除狀態標記」（如 deleted 布林旗標或 deleted 狀態）。標準 delete 方法將更新此狀態，而不是實際刪除資源。引入自訂的 undelete 方法來恢復，以及 expunge 方法進行永久移除。
- **實作：已刪除標記：** 通常是資源上的布林欄位 deleted，應被視為「輸出專用」，不能透過標準更新方法手動設定。
- **修改標準方法：**Get：默認情況下，被軟刪除的資源不應被檢索到，應返回 404。
- List：默認情況下不包含軟刪除資源，但可透過 includeDeleted 旗標或過濾條件來包含。
- Delete：不再實際刪除，而是將資源標記為已刪除，並返回已修改的資源。
- **Undeleting (自訂方法)：** UndeleteChatRoom () 用於將資源從軟刪除狀態恢復。若資源未被軟刪除，應返回錯誤。
- **Expunging (自訂方法)：** ExpungeChatRoom () 用於「永久移除」資源。
- **過期 (Expiration)：** 軟刪除的資源可以在一定時間後自動永久刪除（如 Gmail 垃圾桶 30 天後刪除）。
- **引用完整性：** 軟刪除通常不影響引用這些資源的其他資源的完整性。
- **跨版本添加軟刪除：** 變更為軟刪除可能涉及向後不兼容的變更，需仔細評估。
- **權衡：** 軟刪除提供了數據保護和恢復能力，但增加了 API 的複雜性（更多方法、狀態處理）。

#### 26. 請求去重 (Request Deduplication)

- **動機：** 在不確定性的網路環境中，客戶端發送的非冪等請求（會改變數據的請求）可能因網路故障而重複發送，導致「重複工作」或「不一致的結果」。
- **概述：** 透過在非冪等請求中包含「請求識別碼 (request identifier)」，API 服務可以在檢測到重複請求時返回「快取的回應」，而非再次執行操作。
- **實作：請求識別碼：** 請求介面上的一個可選字串欄位。應由客戶端生成，且在重試時保持不變。若識別碼無效，應拒絕請求。
- **回應快取：** API 服務快取請求識別碼和對應的回應。當檢測到相同識別碼時，直接返回快取回應。
- **一致性：** 確保快取回應與實際的 API 狀態「在語義上保持一致」，避免返回過時的數據。
- **請求 ID 衝突：** 應驗證重複請求的「請求體是否與快取中的請求體一致」，若不一致則返回錯誤（如 409 Conflict），以區分真正的重試和惡意衝突。
- **快取過期：** 快取應設定過期時間（如 5 分鐘），並在每次訪問時重啟計時器，以平衡數據新鮮度和儲存成本。
- **權衡：** 提供了安全重試非冪等請求的能力，但增加了 API 方法的複雜性和快取儲存要求。

#### 27. 請求驗證 (Request Validation)

- **動機：** 某些 API 請求「足夠危險」，需要允許使用者在實際執行前「驗證」請求，以避免意外副作用或錯誤。
- **概述：** 透過在請求中包含一個簡單的布林旗標 validateOnly 來指示請求僅用於驗證，不實際執行。
- **實作：行為：** 驗證請求應努力「模擬實際請求的所有行為」，包括存取控制、數據衝突、引用完整性等檢查。
- **回傳：** 如果請求會成功，回應應盡可能地填充預期的結果；如果會失敗，則返回預期的錯誤。
- **外部依賴：** 驗證應盡可能地驗證外部依賴，但要承認無法控制外部服務的副作用。
- **特殊副作用：** 對於涉及隨機性或依賴外部行為的請求，驗證應返回「看似合理」而非必然真實的回應。
- **權衡：** 提供了重要的安全網，但可能增加 API 的複雜性，尤其是在涉及複雜的外部依賴時。

#### 28. 資源修訂 (Resource Revisions)

- **動機：** 需要「追蹤單一資源隨時間變化的多個修訂版本」，從而「保留歷史記錄」並「啟用回滾等進階功能」。
- **概述：** 透過在現有資源中添加 revisionId（修訂識別碼）和 revisionCreateTime（修訂創建時間）欄位來實現。
- **實作：修訂識別碼：** 應由服務生成，通常是隨機且長度較短的唯一識別碼。
- **創建修訂：** 可以是「隱式創建」（每次資源更新時自動生成）或「顯式創建」（使用者透過自訂 createRevision 方法觸發）。建議預設為每次修改時隱式創建。
- **檢索特定修訂：** 透過在資源 ID 中包含修訂識別碼來檢索特定修訂版本（例如 chatRooms/1/messages/2@abcde）。
- **列出修訂：** 提供自訂的 ListMessageRevisions 方法來瀏覽資源的歷史修訂列表。
- **恢復到先前修訂：** 提供自訂的 RestoreMessageRevision 方法，將資源恢復到特定修訂的狀態。這應是原子操作。
- **刪除修訂：** 提供自訂的 DeleteMessageRevision 方法來刪除特定修訂（例如用於敏感數據清理），不應與標準 Delete 方法混淆。
- **處理子資源：** 通常，修訂應僅關注單一資源及其直接嵌入的數據，而不包括其子資源的整個階層。
- **權衡：** 資源修訂提供了強大的歷史追蹤能力，但也增加了儲存成本和複雜性。

#### 29. 請求重試 (Request Retrial)

- **動機：** 網路固有的不可靠性導致請求失敗。需要定義「重試策略」，以區分哪些錯誤是安全可重試的，以及何時重試。
- **概述：客戶端重試時機：** 大部分情況下，應依賴「指數退避 (exponential back-off)」演算法來確定重試間隔，並引入「隨機抖動 (random jitter)」來避免「踩踏式集群 (stampeding herds)」。
- **伺服器指定重試時機：** 在某些情況下（如限流），伺服器知道確切的重試時間，可透過 Retry-After HTTP 頭部告知客戶端。
- **實作：重試資格：** 錯誤分為「不可重試」、「謹慎重試」和「安全重試」。冪等方法總是安全可重試。
- **指數退避與抖動：** 應定義最大重試次數和總等待時間。隨機抖動用於錯開同步的客戶端請求，避免「踩踏式集群」。
- **Retry-After：** HTTP 頭部，用於伺服器明確告知客戶端何時重試。應使用「持續時間」而非特定時間點，以避免時鐘同步問題。
- **權衡：** 提供了處理暫時性故障的穩健機制，提高了 API 的可靠性，但增加了客戶端的重試邏輯複雜性。

#### 30. 請求認證 (Request Authentication)

- **動機：** 確保傳入的 API 請求是「真實的」，未被篡改，且可追溯來源。
- **概述：** 透過「數位簽名 (Digital Signatures)」實現，它利用非對稱金鑰對（私鑰用於簽名，公鑰用於驗證）。
- **實作：憑證生成：** 客戶端生成金鑰對（私鑰和公鑰），私鑰必須保密。
- **註冊與憑證交換：** 客戶端將公鑰安全地註冊到 API 服務器，以建立身份。
- **生成與驗證原始簽名：** 數位簽名是一種數字，可透過私鑰計算，但難以無私鑰計算；可透過公鑰快速驗證。
- **HTTP 請求指紋 (Fingerprinting HTTP Requests)：** 將請求的關鍵部分（方法、路徑、主機、內容、日期等）組合成一個唯一的「指紋」字串。
- **包含簽名：** 在 HTTP 請求中添加 Digest 頭部（請求體內容的哈希值）和 Signature 頭部（包含簽名本身、用於驗證的 keyId、簽名演算法和指紋包含的頭部列表）。
- **認證請求：** 伺服器接收請求後，重新計算指紋和簽名，並與收到的簽名進行比對，若一致則認證成功。
- **權衡：** 數位簽名提供了強大的安全性，確保了來源、完整性和不可否認性。但它「計算密集」，且在某些情境下（如客戶端不關心事後不可否認性），其他更輕量級的認證機制（如 HMAC 或 OAuth 2.0 的短期存取令牌）可能更合適。