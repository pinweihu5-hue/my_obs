Raft 共識演算法是分散式系統中一個非常重要的概念，讓我用教學的方式來為你詳細解釋這個演算法的核心思想。

## 為什麼我們需要共識演算法？

首先，讓我們想像一個情境：假設你經營一家銀行，有三台伺服器分別在台北、台中、高雄。當客戶在台北存入1000元時，這筆交易必須同時記錄在三個地點的資料庫中，確保資料一致性。但是網路可能中斷，伺服器可能當機，這時候如何確保所有存活的伺服器都能對「帳戶餘額應該是多少」達成共識？

這就是分散式共識問題的核心挑戰。Raft 演算法就是為了解決這個問題而設計的。

## Raft 的設計哲學

在 Raft 出現之前，最著名的共識演算法是 Paxos，但 Paxos 非常複雜，連專家都很難完全理解和正確實作。史丹佛大學的研究者Diego Ongaro和John Ousterhout在2014年提出 Raft，他們的目標很簡單：設計一個「容易理解」的共識演算法。

Raft 的核心理念是「分而治之」，它將複雜的共識問題分解成三個相對獨立的子問題：
1. 領導者選舉
2. 日誌複製
3. 安全性保證

## Raft 的三個核心角色

在 Raft 系統中，每個節點（伺服器）在任何時刻都處於三種狀態之一：

**領導者（Leader）**：負責接收客戶端請求，並將更新操作複製到其他節點。在任何時刻，最多只能有一個領導者。
**跟隨者（Follower）**：被動地接收和回應來自領導者和候選人的請求，不會主動發起任何操作。
**候選人（Candidate）**：用來選舉新領導者的中間狀態。當跟隨者一段時間沒有收到領導者的訊息時，它會變成候選人並發起選舉。

## 領導者選舉

讓我用一個簡單的比喻來解釋選舉過程。想像五個朋友要決定今晚去哪裡吃飯，他們需要選出一個「決策者」來統一協調。

系統剛開始時，所有節點都是跟隨者。每個跟隨者都有一個內建的「耐心計時器」（稱為選舉超時時間），通常設定為150到300毫秒的隨機時間。如果在這段時間內沒有收到領導者的「心跳」訊息，跟隨者就會認為領導者可能已經故障。

這時，這個跟隨者會變成候選人，增加自己的「任期號碼」（term number），然後向所有其他節點發送投票請求。其他節點會根據以下原則決定是否投票：
- 每個任期內只能投一票
- 投給日誌至少和自己一樣新的候選人。

如果候選人獲得大多數節點的投票，它就成為新的領導者。
如果沒有人獲得多數票，就會開始新一輪選舉。

## 日誌複製

一旦選出領導者，它就開始處理客戶端的請求。這個過程就像是一個老師向學生們講課並確保每個人都做好筆記。

當領導者收到客戶端請求時，它會：
1. 首先將這個操作記錄在自己的日誌中，還不會執行。
2. 然後並行地向所有跟隨者發送「附加日誌項目」的請求。
3. 跟隨者收到請求後，會檢查日誌的一致性，如果一切正常就將新的日誌項目加入自己的日誌中，並回應領導者。
4. 當領導者收到大多數節點的成功回應時，它就會提交這個日誌項目，並在下次心跳中通知跟隨者也可以提交。

## 安全性保證

Raft 透過幾個重要的安全規則來確保系統的正確性：

**選舉安全性**：在任何給定的任期內，最多只有一個領導者會被選出。
這是透過每個節點在每個任期內最多只能投一票來保證的。

**領導者只附加原則**：領導者絕不會覆蓋或刪除自己日誌中的項目，只會附加新的項目。

**日誌匹配特性**：如果兩個日誌在某個索引位置包含相同任期號的項目，那麼它們在該位置之前的所有項目都是相同的。

**領導者完整性**：如果某個日誌項目在給定任期內被提交，那麼這個項目一定會出現在所有更高任期號的領導者的日誌中。

## 實際應用場景

Raft 演算法在現實世界中有許多重要應用。
etcd 是 Kubernetes 生態系統的核心組件，它使用 Raft 來管理叢集的配置資訊。
Consul 使用 Raft 來維護服務發現和配置管理的一致性。
許多分散式資料庫系統，如 TiKV、CockroachDB 等，也都採用了 Raft 演算法。

## 與其他共識演算法的比較

相比於經典的 Paxos 演算法，Raft 的最大優勢是可理解性。Paxos 雖然在理論上很優雅，但實作起來極其複雜，容易出錯。Raft 透過明確的角色分工和狀態機設計，讓開發者更容易理解和正確實作。

不過，Raft 也有其限制。它是一個強一致性的演算法，這意味著在網路分割的情況下，如果無法與大多數節點通訊，系統就無法處理寫入請求。在某些需要高可用性勝過強一致性的場景中，可能需要考慮其他方案。