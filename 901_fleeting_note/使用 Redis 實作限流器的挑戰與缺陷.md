- related: [[rate limit]]



作者 **Andrew Miller** 深入分析了使用 Redis 實作限流器時的常見方法與問題，指出雖然 Redis 因其記憶體型資料庫特性看似適合，但實務上幾乎所有簡單實作都存在嚴重缺陷，甚至許多線上範例與官方文件都有問題。

---

## 一、Redis 限流器的流行與疑問

* 許多公司（甚至嚴謹企業）使用 Redis 實作限流器。
* 作者原本認為 Redis 僅適合快取用途。
* 經過兩天研究後發現：

  > 幾乎所有找到的方案都不穩固，甚至 Google 搜尋結果與官方文件也有同樣問題。

---

## 二、常見實作方式與缺陷

### 1. 固定窗口（Fixed Window）– 基礎指令實作

**程式碼範例：**

```redis
SET rate 0 NX EX 1
INCR rate
```

**問題：競態條件**

* `SET` 與 `INCR` 分開執行時，若 `INCR` 到達時鍵已過期，會重新建立但沒有過期時間，導致計數器永不失效。


**修正嘗試（使用事務）：**

```redis
MULTI
SET rate 0 NX EX 1
INCR rate
EXEC
```

* 修正了原子性，但需要事務，且部分 Redis 客戶端（如 Rust 在集群模式）不支援。

---

### 2. 固定窗口（時間戳鍵法）

**概念：**
使用時間戳作為鍵名，每個窗口建立新鍵，設定過期。

**範例：**

```redis
INCR rate_1754317189
EXPIRE rate_1754317189 10
```

**優化嘗試：**

* 僅在 `INCR` 回傳 1 時才執行 `EXPIRE`，減少網路往返。

**問題：**
* **時鐘偏移**：不同客戶端時鐘不同，請求可能落入不同窗口。
* **EXPIRE 失敗**：若 `EXPIRE` 未執行成功，鍵將永久存在，造成記憶體洩漏與限速錯誤。

---

### 3. 滑動日誌窗口（Sliding Log Window）

**概念：**
用 ZSET 記錄每個請求時間戳，定期刪除過期項目。

**範例：**

```redis
ZREMRANGEBYSCORE rate 0 $T
ZCARD rate
ZADD rate $NOW $UNIQUE
```

**問題：**

* 效能不佳（O(N) 操作）。
* 若 `$UNIQUE` 設錯，攻擊時會有大量重複紀錄被丟棄，實際限速高於預期。
* 與固定窗口一樣，無法避免邊界突發（burst）。

---

## 三、窗口限流的根本缺陷

* **固定窗口**與**滑動窗口**都無法保證「真實速率」，容易在窗口邊界發生突發流量。
* 例如：

  * 限制：每分鐘 60 請求
  * 可能行為：在 1 秒內發出 60 請求
  * 影響：瞬間造成服務壓力

---

## 四、令牌桶（Token Bucket）的優勢與 Redis 限制

* **優勢**：能精準控制速率，允許可控的突發流量。
* **問題**：在 Redis 中實作令牌桶需要兩個變數，必須先讀取再更新，無法用基本指令保證原子性。

---

## 五、Lua 腳本方案

**原因：**
只有 Lua 腳本或 Redis 模組能在伺服器端原子完成令牌桶邏輯。

**Lua 腳本特性：**

* 腳本執行期間 Redis 會暫停其他操作。
* 可以直接呼叫 Redis 指令，確保原子性。

**作者質疑：**

> 我們只是為了在 Redis 中存一個整數，卻要學一門新語言並改變 Redis 的用途。

---

## 六、線上方案的普遍缺陷

作者檢視了 Google 搜尋「redis rate limiter」前 25 筆結果及官方文件，發現：

* 大多數不支援 Redis 集群。
* 常見缺陷：

  1. **記憶體洩漏** – 無限新增 ZADD 項目（PEAKSCALE, CLASSDOJO）。
  2. **過期時間延長** – 請求會持續延長封鎖時間（REDISIO - JAVA - REA - LUA）。
  3. **競態條件** – 導致大量請求同時通過（INFOWORLD, 2017）。
  4. **EXPIRE 丟失** – 鍵永不過期，或 DECRBY 導致永久阻塞（REDISIO - RL）。

---

## 七、效能顧慮

* 作者預告第二部分將證明 Redis 限流器的效能可能下降 10 倍。
* 即使在 Redis Cluster 上，普通硬體每個計數器每秒僅能處理 \~100K 請求。

---

## 八、核心結論

1. Redis 並非理想的限流器工具。
2. 簡單的 Redis 限流器（INCR + EXPIRE）幾乎必定有競態條件或原子性問題。
3. 窗口型限流器無法防止邊界突發流量。
4. 精確限流（令牌桶）在 Redis 中只能靠 Lua 腳本實作，但這改變了 Redis 的設計初衷。
5. 多數網路教學與官方範例都存在嚴重缺陷。
6. 將複雜邏輯塞進資料庫端屬於反模式，增加複雜性與維護成本。
7. 效能與可擴展性在此模式下也會受限。

---

如果你需要的話，我可以幫你**另外整理出一份「正確安全的令牌桶 Redis Lua 實作範例」**，並附上完整流程與防錯機制。這樣你可以直接對照現有錯誤範例看差異。
你要我幫你做這份範例嗎？
